<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="JAVA基础第一章  JAVA 变量 一个字节（有8个位）表示的范围 00000000-01111111 ：0 ~127 10000000-11111111 ： -128 ~ -1 原因：负数是以补码的形式存储的：128的二进制：10000000-&gt;按位取反在加1-&gt;10000000 所以1用10000000表示-128  在Java语言中数据类型主要分为两大类： （1）基本数据类型（">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2022/03/25/JAVA%E5%9F%BA%E7%A1%80/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="JAVA基础第一章  JAVA 变量 一个字节（有8个位）表示的范围 00000000-01111111 ：0 ~127 10000000-11111111 ： -128 ~ -1 原因：负数是以补码的形式存储的：128的二进制：10000000-&gt;按位取反在加1-&gt;10000000 所以1用10000000表示-128  在Java语言中数据类型主要分为两大类： （1）基本数据类型（">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210723230705601.png">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210723233029027.png">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210724110149531.png">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210724131728190.png">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210724171325385.png">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210724182437644.png">
<meta property="og:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210724191930478.png">
<meta property="article:published_time" content="2022-03-25T14:19:19.140Z">
<meta property="article:modified_time" content="2021-07-25T06:44:20.525Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:/Users/19591/AppData/Roaming/Typora/typora-user-images/image-20210723230705601.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JAVA基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/25/JAVA%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2022-03-25T14:19:19.140Z" itemprop="datePublished">2022-03-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h1><h2 id="第一章-JAVA-变量"><a href="#第一章-JAVA-变量" class="headerlink" title="第一章  JAVA 变量"></a>第一章  JAVA 变量</h2><ol>
<li><p><strong>一个字节</strong>（有8个位）表示的范围</p>
<p>00000000-01111111 ：0 ~127</p>
<p>10000000-11111111 ： -128 ~ -1 原因：负数是以补码的形式存储的：128的二进制：10000000-&gt;按位取反在加1-&gt;10000000 所以1用10000000表示-128</p>
</li>
<li><p>在Java语言中数据类型主要分为两大类：</p>
<p>（1）基本数据类型（记住）</p>
<p>byte、short、int、long、float、double、boolean、char</p>
<p>（2）引用数据类型（了解）</p>
<p>数组、类、接口、枚举、标注<strong>浮点类型</strong></p>
</li>
<li><p>Java语言中用于描述小数数据的类型：float 和 double，推荐double类型</p>
<p>其中float类型在内存空间占<strong>4个字节</strong>，叫做单精度浮点数，可以表示7<strong>位有效数字</strong>，范围：-3.403E38<del>3.403E38。 其中double类型在内存空间占8个字节，叫做双精度浮点数，可以表示15位有效数字，范围：-1.798E308</del>1.798E308。 Java程序中直接写出的小数数据叫做直接量，<strong>默认为double类型，</strong>若希望表达float类型的直接量，则需要在直接量的后面加上f或者F</p>
</li>
<li><p>char 表示4个字节</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">65535</span>;</span><br><span class="line">      <span class="type">char</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">      System.out.println(b); <span class="comment">// char b = 65536; 报错，char类型的范围是0-65535,4个字节</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line">      System.out.println(c);<span class="comment">// 乱码</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">d</span> <span class="operator">=</span> <span class="string">&#x27;d&#x27;</span>;</span><br><span class="line">      System.out.println((<span class="type">int</span>)d);<span class="comment">//100</span></span><br><span class="line">      <span class="type">char</span> <span class="variable">e</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">      System.out.println(e);<span class="comment">//d</span></span><br></pre></td></tr></table></figure>

<p>常见的ASCII有：’0’ - 48 ‘A’ - 65 ‘a’ - 97 空格 - 32 换行符 - 10</p>
<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210723230705601.png"></p>
<p>Java字符类型采用<strong>Unicode字符集编码</strong>。Unicode是世界通用的定长字符集，所有的字符都是16位。要求掌握的转义字符有：</p>
<p>\“  表示 “      \‘ 表示 ‘   \ \ 表示 \   \t - 制表符    \n - 换行符.</p>
<p>char 是两个字节，int 转为 char会截断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">635535</span></span><br><span class="line"><span class="type">char</span> <span class="variable">h</span> <span class="operator">=</span>(<span class="type">char</span>) i;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> <span class="variable">q1</span> <span class="operator">=</span> <span class="number">65535</span>;<span class="comment">//不报错</span></span><br><span class="line"><span class="type">char</span> <span class="variable">q</span> <span class="operator">=</span> <span class="number">65536</span>;<span class="comment">//报错</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><strong>基本数据类型之间的转换</strong></li>
</ol>
<p>Java语言中基本数据类型之间的转换方式：自动类型转换和强制类型转换。</p>
<p>其中自动类型转换主要指从小类型到大类型之间的转换。</p>
<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210723233029027.png" alt="image-20210723233029027"></p>
<h2 id="第二章：Java语言的运算符"><a href="#第二章：Java语言的运算符" class="headerlink" title="第二章：Java语言的运算符"></a><strong>第二章：</strong>Java语言的运算符</h2><ol>
<li><strong>逻辑运算符的短路特性</strong></li>
</ol>
<p>对于逻辑<strong>与</strong>运算符来说，若第一个表达式为假则结果为假，此时跳过第二个表达式；</p>
<p>对于逻辑<strong>或</strong>运算符来说，若第一个表达式为真则结果为真，此时跳过第二个表达式</p>
<ol start="2">
<li><strong>移位运算符</strong></li>
</ol>
<p>&lt;&lt; 左移运算符，用于将数据的二进制位向左移动，右边使用0补充</p>
<p>&gt;&gt; 右移运算符，用于将数据的二进制位向右移动，<strong>左边使用符号位补充</strong></p>
<p>&gt;&gt;&gt; 表示逻辑右移运算符，用于将数据的二进制位向右移动，左边使用0补充</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0b10001</span>;<span class="comment">//2进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0xab10</span>;<span class="comment">//16进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="number">0_777</span>;<span class="comment">//8进制</span></span><br><span class="line"><span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="number">0777</span>;<span class="comment">//8进制、</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0b11111111</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(f&lt;&lt;<span class="number">1</span>));<span class="comment">//111111110</span></span><br><span class="line"><span class="type">int</span> <span class="variable">g</span> <span class="operator">=</span> <span class="number">0b111111111</span>;<span class="comment">//</span></span><br><span class="line">System.out.println(Integer.toBinaryString(g&gt;&gt;<span class="number">1</span>));<span class="comment">//11111111</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//往右移动的时候，最高位补的是符号位</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">k</span> <span class="operator">=</span> -<span class="number">128</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(k));<span class="comment">//11111111111111111111111110000000</span></span><br><span class="line">System.out.println(Integer.toBinaryString(k&gt;&gt;<span class="number">1</span>));<span class="comment">//11111111111111111111111111000000</span></span><br><span class="line">System.out.println(Integer.toBinaryString(k&gt;&gt;&gt;<span class="number">1</span>));<span class="comment">//1111111111111111111111111000000</span></span><br><span class="line"><span class="type">int</span>  <span class="variable">k1</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">System.out.println(Integer.toBinaryString(k1));<span class="comment">//10000000</span></span><br><span class="line">System.out.println(Integer.toBinaryString(k1&gt;&gt;<span class="number">1</span>));<span class="comment">//1000000</span></span><br></pre></td></tr></table></figure>



<ol start="3">
<li><strong>位运算符</strong></li>
</ol>
<p>&amp; 表示按位与运算符，按照二进制位进行与运算，同1为1，一0为0.</p>
<p>| 表示按位或运算符，按照二进制位进行或运算，一1为1，同0为0.</p>
<p>~ 表示按位取反运算符，按照二进制位进行取反，1为0，0为1.</p>
<p>^ 表示按位异或运算符，按照二进制位进行异或运算，同为0，不同为1.</p>
<h2 id="第四章：流程控制语句"><a href="#第四章：流程控制语句" class="headerlink" title="第四章：流程控制语句"></a><strong>第四章：流程控制语句</strong></h2><h3 id="1-switch-case分支结构"><a href="#1-switch-case分支结构" class="headerlink" title="1. switch case分支结构"></a>1. switch case分支结构</h3><p>• switch(变量&#x2F;表达式) {</p>
<p>case 字面值1: 语句块1; break;</p>
<p>case 字面值2: 语句块2; break;</p>
<p>…</p>
<p>default:语句块n;</p>
<p>}</p>
<p><strong>switch()中支持的数据类型有：byte、short、char以及int类型，从jdk1.5开始支持枚举类型，从jdk1.7开始支持String类型</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">switch</span>(a) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">1</span> :</span><br><span class="line">              System.out.println(<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">              System.out.println(<span class="number">2</span>);</span><br><span class="line">          <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">              System.out.println(<span class="number">3</span>);</span><br><span class="line">          <span class="keyword">default</span>:</span><br><span class="line">              System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>注意： case Season.summer:&#x2F;&#x2F;<strong>编译时报错</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.spring;</span><br><span class="line">        <span class="keyword">switch</span> (season)&#123;</span><br><span class="line">            <span class="comment">//case Season.summer://编译时报错</span></span><br><span class="line">            <span class="keyword">case</span> summer:</span><br><span class="line">                System.out.println(<span class="string">&quot;夏天&quot;</span>);</span><br><span class="line">            <span class="keyword">case</span> fail:</span><br><span class="line">            <span class="keyword">case</span> spring:</span><br><span class="line">            <span class="keyword">case</span> winner:</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>习惯上，需要使用哪个类里的变量，通常都要加类名以限定，所以按这个习惯来思考的话，想死都想不到①为什么会报错。java给的理由是，因为在switch标签已经指定了枚举类型，所以case标签中就不要再指定了，这样代码能省一点是一点。不过有的人还是习惯把类名限定给加上去，虽然作用没啥，但是可读性要更好一点，为此代码量作出一丢丢的让步也是可以的！但是java官方说了，不行！！我们都是有原则的人，代码简洁是必须的，觉得可读性不行只能怪你太蠢啦！所以现在的情况就是，enum和switch搭档，必须按这个规矩干，限定类名不能加！</p>
<ol start="2">
<li><strong>双重for循环的特点</strong></li>
</ol>
<p><strong>外层循环用于控制打印的行数，内层循环用于控制打印的列数，</strong>外层循环改一下，内层循环从头到尾跑一圈。</p>
<p>在以后的开发中若需要打印多行多列时，需要使用双重循环。多重循环不宜嵌套太多层，否则效率很低。一般到三重循环即可，最常</p>
<p>见的就是双重循环。</p>
<h2 id="第五章数组的概念和应用"><a href="#第五章数组的概念和应用" class="headerlink" title="第五章数组的概念和应用"></a>第五章<strong>数组的概念和应用</strong></h2><ol>
<li><h3 id="一维数组的基本概念"><a href="#一维数组的基本概念" class="headerlink" title="一维数组的基本概念"></a><strong>一维数组的基本概念</strong></h3><p>当需要在Java程序中记录单个数据内容时，则声明一个变量即可。当需要在Java程序中记录多个类型相同的数据内容时，则声明一个一维数组即可，一维数组本质上就是在内存空间中申请一段<strong>连续的存储单元</strong>。<strong>数组是相同数据类型的多个元素的容器，</strong>元素按<strong>线性顺序</strong>排列，在Java语言中体现为一种<strong>引用数据类型</strong>。</p>
<p>boolean数组初始化为false</p>
</li>
<li><h3 id="数组的优缺点"><a href="#数组的优缺点" class="headerlink" title="数组的优缺点"></a><strong>数组的优缺点</strong></h3><p>可以直接通过下标(或索引)的方式访问指定位置的元素，速度很快。数组要求所有元素的类型相同。数组要求内存空间连续，并且长度一旦确定就不能修改。 增加和删除元素时可能移动大量元素，效率低。</p>
</li>
</ol>
<h3 id="3-数组工具类"><a href="#3-数组工具类" class="headerlink" title="3.数组工具类"></a>3.<strong>数组工具类</strong></h3><p>​    java.util.Arrays类可以实现对数组中元素的遍历、查找、排序等操作</p>
<ul>
<li>static String toString(int[] a)  输出数组中的内容</li>
<li>static void fill(int[] a, int val)  将参数指定元素赋值给数组中所有元素</li>
<li>static boolean equals(boolean[] a, boolean[] a2)  判断两个数组元素内容和次序是否相同</li>
<li>static void sort(int[] a)  对数组中的元素进行从小到大排序</li>
<li>static int binarySearch(int[] a, int key)  从数组中查找参数指定元素所在的位置</li>
</ul>
<h2 id="第六章-类和对象"><a href="#第六章-类和对象" class="headerlink" title="第六章 类和对象"></a><strong>第六章 类和对象</strong></h2><h3 id="1-面向对象编程的概念"><a href="#1-面向对象编程的概念" class="headerlink" title="1. 面向对象编程的概念"></a><strong>1. 面向对象编程的概念</strong></h3><p>​    万物皆对象。</p>
<p>​    面向对象指以属性和行为的观点去分析现实生活中的事物。</p>
<p>​    面向对象编程指先以面向对象的思想进行分析，然后使用面向对象的编程语言进行表达的过程。</p>
<p>​    面向对象编程是软件产业化发展的需求。</p>
<p>​    理解面向对象的思想精髓(封装、继承、多态)，至少掌握一种编程语言。</p>
<h3 id="2-类和对象及引用"><a href="#2-类和对象及引用" class="headerlink" title="2. 类和对象及引用"></a><strong>2. 类和对象及引用</strong></h3><ol>
<li><strong>类和对象的概念</strong></li>
</ol>
<ul>
<li>对象主要指现实生活中客观存在的实体，在Java语言中对象体现为内存空间中的一块存储区域。</li>
<li>类简单来就是“分类”，是对具有相同特征和行为的多个对象共性的抽象描述，在Java语言中体现为一种引用数据类型，里面包含了描述特征&#x2F;属性的成员变量以及描述行为的成员方法。 </li>
<li>类是用于构建对象的模板，对象的数据结构由定义它的类来决定。</li>
<li>创建对象的本质就是在内存空间的堆区申请一块存储区域， 用于存放该对象独有特征信息。</li>
</ul>
<ol start="2">
<li><strong>引用的定义</strong></li>
</ol>
<ul>
<li><p>基本概念</p>
<p>a.使用<strong>引用数据类型定义的变量叫做引用型变量，简称为”引用”。</strong></p>
<p>b.引用变量主要用于<strong>记录对象在堆区中的内存地址信息</strong>，便于下次访问。</p>
</li>
<li><p>语法格式</p>
<p>类名 引用变量名;</p>
<p>引用变量名.成员变量名;</p>
</li>
</ul>
<p> 3.<strong>可变参数</strong></p>
<p>​        一个方法的形参列表中最多只能声明一个可变长形参，并且需要放到参数列表的<strong>末尾</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span>... c)</span> &#123;<span class="comment">//c 类似一个数组</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> a + b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; c.length;i++) &#123;</span><br><span class="line">        sum+=c[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><strong>方法的传参过程</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> ia, <span class="type">int</span> ib)</span>&#123;</span><br><span class="line">    … … … </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>; </span><br><span class="line"><span class="type">int</span> b=<span class="number">6</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> m.max(a,b);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>为main方法中的变量a、b、res分配空间并初始化。</p>
</li>
<li><p>调用max方法，为max方法的形参变量ia、ib分配空间。</p>
</li>
<li><p><strong>将实参变量的数值赋值到形参变量的内存空间中。</strong></p>
</li>
<li><p>max方法运行完毕后返回，形参变量空间释放。</p>
</li>
<li><p>main方法中的res变量得到max方法的返回值。</p>
</li>
<li><p>main方法结束后释放相关变量的内存空间。</p>
<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210724110149531.png" alt="image-20210724110149531"></p>
</li>
</ul>
<ol start="5">
<li><strong>参数传递的注意事项</strong></li>
</ol>
<ul>
<li>基本数据类型的变量作为方法的参数传递时，形参变量数值的改变通常不会影响到实参变量的数值，因为两个变量有各自独立的内存空间；</li>
<li>引用数据类型的变量作为方法的参数传递时，形参变量指向内容的改变会影响到实参变量指向内容的数值，因为两个变量指向同一块内存空间；</li>
<li>当引用数据类型的变量作为方法的参数传递时，若形参变量改变指向后再改变指定的内容，则通常不会影响到实参变量指向内容的改变，因为两个变量指向不同的内存空间。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   System.out.println(Arrays.toString(arr));<span class="comment">//[0, 0, 1]</span></span><br><span class="line">   System.out.println(Arrays.toString(test.show(arr)));<span class="comment">//[1, 0, 1]</span></span><br><span class="line">   System.out.println(Arrays.toString(arr));<span class="comment">//[1, 0, 1]</span></span><br><span class="line"><span class="comment">//arr的值也改变了</span></span><br><span class="line">   <span class="keyword">public</span> <span class="type">int</span>[] show(<span class="type">int</span>[] array) &#123;</span><br><span class="line">       array[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">       <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<ol start="6">
<li><strong>传参的相关概念</strong></li>
</ol>
<p>参数分为形参和实参，定义方法时的参数叫形参，调用方法时传递的参数叫实参。 </p>
<p>调用方法时采用值传递把实参传递给形参，方法内部其实是在使用形参。 </p>
<p><strong>所谓值传递就是当参数是基本类型时，传递参数的值，比如传递i&#x3D;10，真实传参时，把10赋值给了形参。当参数是对象时，传递的是对象的地址，也就是把对象的地址赋值给形参</strong></p>
<p>如下：str 在调入replace()时，是把“hello”的地址复制给了replace（）中的形参str1，因此在replace中改变对象的属性值时，函数外面的</p>
<p>对象也会感知到，因为指向了一个对象。</p>
<p>但是test5()里的str的地址指向不会变的（值传递的原因），因而打印出来的还是”hello”。如果是<strong>引用传递</strong>就会改变。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">       replace(str);</span><br><span class="line">       System.out.println(str);<span class="comment">//&quot;hello 是值传递，把地址复制过去，因此该方法的str的地址不会被改变</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">replace</span><span class="params">(String str1)</span> &#123;</span><br><span class="line">       str = <span class="string">&quot;hello1&quot;</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>





<h2 id="第七章：方法和封装"><a href="#第七章：方法和封装" class="headerlink" title="第七章：方法和封装"></a><strong>第七章：方法和封装</strong></h2><h3 id="一-方法"><a href="#一-方法" class="headerlink" title="一 方法"></a>一 方法</h3><p><strong>1. 重载的体现形式</strong></p>
<p>​    方法重载的主要形式体现在：参数的<strong>个数</strong>不同、参数的<strong>类型</strong>不同、<strong>参数的顺序不同</strong>，<strong>与返回值类型和形参变量名无关</strong>，但建议返回值类    型最好相同。</p>
<p>​    判断方法能否构成重载的核心：调用方法时能否加以区分。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  	<span class="comment">// public int say()&#123;&#125;//error</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="type">int</span> a)</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="type">int</span> a,String b)</span>&#123;&#125;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(String b,<span class="type">int</span> a)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>this关键字</p>
<ul>
<li><p>this关键字本质上就是<strong>当前类类型的引用变量。</strong></p>
</li>
<li><p>当局部变量名与成员变量名相同时，在方法体中会优先使用局部变量(就近原则)，若希望使用成员变量，则需要在成员变量的前面加上this.的前缀，明确要求该变量是成员变量</p>
</li>
<li><p><strong>引用类型变量用于存放对象的地址</strong>，可以给引用类型赋值为null，<strong>表示不指向任何对象。</strong></p>
</li>
<li><p>当某个引用类型变量为null时无法对对象实施访问（因为它没有指向任何对象）。此时，如果通过引用访问成员变量或调用方法，会产生NullPointerException 异常。</p>
</li>
</ul>
</li>
</ol>
<h3 id="二、-封装"><a href="#二、-封装" class="headerlink" title="二、 封装"></a>二、 <strong>封装</strong></h3><ol>
<li><p><strong>封装的概念</strong></p>
<p>通常情况下可以在测试类给成员变量赋值一些合法但不合理的数值，无论是编译阶段还是运行阶段都不会报错或者给出提示，此时与现实生活不符。</p>
<p>为了避免上述错误的发生，就需要对成员变量进行密封包装处理，来隐藏成员变量的细节以及保证成员变量数值的合理性，该机制就叫做封装。</p>
</li>
<li><p><strong>封装的实现流程</strong></p>
<p>私有化成员变量，使用private关键字修饰。</p>
<p>提供公有的get和set方法，并在方法体中进行<strong>合理值的</strong>判断。</p>
<p>在构造方法中调用set方法进行<strong>合理值的判断</strong>。</p>
</li>
</ol>
<h2 id="第八章static关键字和继承"><a href="#第八章static关键字和继承" class="headerlink" title="第八章static关键字和继承"></a>第八章<strong>static关键字和继承</strong></h2><h4 id="一-、staitic"><a href="#一-、staitic" class="headerlink" title="一 、staitic"></a>一 、staitic</h4><ol>
<li><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>使用static关键字修饰成员变量表示静态的含义，此时<strong>成员变量由对象层级提升为类层级</strong>，也就是<strong>整个类只有一份并被所有对象共享</strong>，该成员变量随着类的加载准备就绪，与是否创建对象无关。</p>
<p>static关键字修饰的成员可以使用引用.的方式访问，但推荐类名.的方式</p>
</li>
<li><p><strong>构造块和静态代码块</strong> </p>
<p>构造块：在类体中直接使用{}括起来的代码块。</p>
<p><strong>每创建一个对象都会执行一次构造块</strong>。 </p>
<p>静态代码块：使用static关键字修饰的构造块。</p>
<p><strong>静态代码块随着类加载时执行一次。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 测试代码块执行顺序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">       <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">   &#125;</span><br><span class="line">   运行结果：</span><br><span class="line">   这是静态代码块</span><br><span class="line">   这是普通代码块</span><br><span class="line">   这是构造方法</span><br><span class="line">   这是普通代码块</span><br><span class="line">   这是构造方法</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.wencai.base.<span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是静态代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是普通代码块&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;这是构造方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Date <span class="title function_">getBirthday</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBirthday</span><span class="params">(Date birthday)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, birthday=&quot;</span> + birthday +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    注：更改普通代码块和构造方法的位置，还是先执行普通代码块。</p>
<p>​        在一个main方法内，静态代码块只会加载一次。在构造对象时不会再在执行该代码块。</p>
<h4 id="二、继承"><a href="#二、继承" class="headerlink" title="二、继承"></a>二、继承</h4><ol>
<li><p><strong>继承的概念</strong></p>
<p>当多个类之间有相同的特征和行为时，可以将相同的内容提取出来组成一个公共类，让多个类吸收公共类中已有特征和行为而    在多个类型只需要编写自己独有特征和行为的机制，叫做继承。</p>
<p>使用继承提高了代码的复用性，可维护性及扩展性，是多态的前提条件</p>
</li>
<li><p><strong>继承的特点</strong></p>
<p>子类不能继承父类的构造方法和私有方法，但<strong>私有成员变量可以被继承只是不能直接访问</strong>，可以用set方法访问。</p>
<p>无论使用何种方式构造子类的对象时都会<strong>自动调用父类的无参构造方法</strong>，来初始化<strong>从父类中继承的成员变量</strong>，相当于在构造方    法的第一行增加代 码super()的效果。  </p>
<p>super()位于子类构造方法的第一行,在其他位置会编译报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> <span class="keyword">extends</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> String score;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Person</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="built_in">super</span>();		  <span class="comment">//调用父类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>.setAge(<span class="number">100</span>);<span class="comment">//继承了User中的age属性</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(Integer age)</span>&#123;</span><br><span class="line">        setAge(age);</span><br><span class="line">        <span class="built_in">super</span>.setAge(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
<li><h5 id="代码块执行顺序"><a href="#代码块执行顺序" class="headerlink" title="代码块执行顺序"></a>代码块执行顺序</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class Person extends User&#123;</span><br><span class="line">    private String address;</span><br><span class="line">    private String score;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;这是子类的静态代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;这是子类的普通代码块&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Person()  &#123;</span><br><span class="line">        super();          //位于代码的第一行,在下面会编译报错</span><br><span class="line">        System.out.println(&quot;这是子类的构造方法&quot;);</span><br><span class="line">        super.setAge(100);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setAge(Integer age)&#123;</span><br><span class="line">        //super();//不能用在一般方法中</span><br><span class="line">        setAge(age);</span><br><span class="line">        super.setAge(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    结果：</p>
<p>​    这是父类的静态代码块<br>​    这是子类的静态代码块<br>​    这是父类的普通代码块<br>​    这是父类的构造方法<br>​    这是子类的普通代码块<br>​    这是子类的构造方法</p>
<ol start="4">
<li><strong>常用的访问控制符</strong></li>
</ol>
<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210724131728190.png" alt="image-20210724131728190"></p>
</li>
<li><p><strong>package语句的由来</strong></p>
<p>定义类时需要指定类的名称，但如果仅仅将类名作为类的唯一标识，则不可避免的出现命名冲突的问题。这会给组件复用以及    团队间的合作造成很大的麻烦！ 在Java语言中，用包（package）的概念来<strong>解决命名冲突</strong>的问题。</p>
<ul>
<li><strong>包的定义</strong></li>
</ul>
<p>在定义一个类时，除了定义类的名称一般还要指定一个包名，格式如下：</p>
<p>package 包名; </p>
<p>package 包名1.包名2.包名3…包名n; </p>
<p>为了实现项目管理、解决命名冲突以及权限控制的效果</p>
</li>
<li><p><strong>final关键字</strong></p>
<p><strong>定义</strong></p>
<p>final本意为”最终的、不可改变的”，可以修饰类、成员方法以及成员变量</p>
<p><strong>使用方式</strong></p>
<p>final关键字<strong>修饰类</strong>体现在该类<strong>不能被继承</strong>。主要用于防止滥用继承，如：java.lang.String类等</p>
<p>final关键字<strong>修饰成员方法</strong>体现在该方法<strong>不能被重写但可以被继承</strong>。主要用于防止不经意间造成重写，如：java.text.Dateformat类中format方法等</p>
<p>final关键字<strong>修饰成员变量</strong>体现在该<strong>变量必须初始化且不能改变</strong>。主要用于防止不经意间造成改变，如：java.lang.Thread类中MAX_PRIORITY等。</p>
<p>一个以final修饰的<strong>引用数据类型变量</strong>，<strong>无法再指向一个新的对象</strong>,但是<strong>对象的属性值</strong>是可以变的</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">final String s1 = &quot;nihao&quot;;</span><br><span class="line">//s1 = &quot;hello&quot;; //编译报错，不能指向新对象</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h2 id="第九章：多态和特殊类"><a href="#第九章：多态和特殊类" class="headerlink" title="第九章：多态和特殊类"></a><strong>第九章：多态和特殊类</strong></h2><h3 id="一、-多态"><a href="#一、-多态" class="headerlink" title="一、 多态"></a>一、 <strong>多态</strong></h3><ol>
<li><p><strong>多态的语法格式</strong></p>
<p>父类类型 引用变量名 &#x3D; new 子类类型();</p>
</li>
<li><p><strong>多态的特点</strong></p>
<p>当父类类型的引用指向子类类型的对象时，父类类型的引用可以直接调用父类独有的方法。</p>
<p>当父类类型的引用指向子类类型的对象时，父类类型的引用<strong>不可以直接</strong>调用子类独有的方法。<strong>可以将父类强转成子类在调用。</strong></p>
<p>对于父子类都有的非静态方法来说，<strong>编译阶段调用父类版本，运行阶段调用子类重写的版本</strong>（动态绑定）。</p>
<p>对于父子类都有的静态方法来说，编译和运行阶段都调用父类版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">      user.say();<span class="comment">//我是person</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>引用数据类型之间的转换</strong></p>
</li>
</ol>
<p>​      引用数据类型之间的转换方式有两种：<strong>自动类型转换 和 强制类型转换</strong>。</p>
<p>​      <strong>自动类型转换</strong>主要指小类型向大类型的转换，也就是<strong>子类转为父类</strong>，也叫做向上转型。</p>
<p>​      强制类型转换主要指<strong>大类型向小类型的转换</strong>，也就是父类转为子类，也叫做向下转型或显式类型转换。</p>
<p>​      引用数据类型之间的转换<strong>必须发生在父子类之间</strong>，否则编译报错。</p>
<pre><code> 若强转的目标类型并不是该引用真正指向的数据类型时则编译通过，运行阶段发生类型转换异常。、
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) person;<span class="comment">// 运行时确定出person是Person类，不是User类。Person类和Cat不是父子关系，而是兄弟关系，不能转换</span></span><br><span class="line"><span class="comment">//java.lang.ClassCastException: com.wencai.base.var.Person cannot be cast to com.wencai.base.var.Cat</span></span><br></pre></td></tr></table></figure>

<pre><code> 为了避免上述错误的发生，**应该在强转之前进行判断**，格式如下：
</code></pre>
<p>​     if(引用变量 <strong>instanceof</strong> 数据类型) </p>
<p>​     判断引用变量指向的对象是否为后面的数据类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">User</span> <span class="variable">person</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="keyword">if</span>(person <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">    <span class="type">Cat</span> <span class="variable">cat</span> <span class="operator">=</span> (Cat) person;<span class="comment">//编译期报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​     instanceof 严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">result</span> <span class="operator">=</span> obj <span class="keyword">instanceof</span> Class</span><br></pre></td></tr></table></figure>

<p>​    其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接或间接子类，或者是其接口的实现类，    结果result 都返回 true，否则返回false。</p>
<p>　注意：<strong>编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译</strong>，具体看运行时    定。</p>
<h5 id="4-多态的意义"><a href="#4-多态的意义" class="headerlink" title="4.多态的意义"></a>4.多态的意义</h5><p>在于<strong>屏蔽不同子类的差异性</strong>实现通用的编程带来不同的效果。</p>
<h2 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a><strong>二、抽象类</strong></h2><ol>
<li><p><strong>抽象方法的概念</strong></p>
<p>抽象方法主要指不能具体实现的方法并且使用abstract关键字修饰，也就是没有方法体，抽象类主要指不能具体实例化的类并且使用abstract关键字修饰，也就是不能创建对象</p>
<p>具体格式如下：</p>
<p>访问权限 abstract 返回值类型 方法名(形参列表); </p>
<p>public abstract void cry();</p>
</li>
</ol>
<p>​    2. <strong>抽象类和抽象方法的关系</strong></p>
<p>​    抽象类中可以有成员变量、构造方法、成员方法；</p>
<p>​    抽象类中可以没有抽象方法，也可以有抽象方法；</p>
<p>​    <strong>拥有抽象方法的类必须是抽象类，</strong>因此真正意义上的抽象类应该是具有抽象方法并且使用abstract关键字修饰的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="keyword">class</span> <span class="title class_">TestAbstract</span> &#123;<span class="comment">//报错，抽象方法必须在抽象类的基础上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 3.<strong>抽象类的实际意义</strong></p>
<p>​    抽象类的实际意义<strong>不在于创建对象而在于被继承。</strong></p>
<p>​    当一个类继承抽象类后必须重写抽象方法，否则该类也变成抽象类，也就是<strong>抽象类对子类具有强制性和规范性</strong>，因此叫做模板设计模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">TestAbstract1</span> <span class="keyword">extends</span> <span class="title class_">TestAbstract</span>&#123;<span class="comment">// TestAbstract抽象类，不复写方法就必须仍然是抽象类</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a><strong>三、接口</strong></h2><ol>
<li><p><strong>接口的基本概念</strong></p>
<p>接口就是一种比抽象类还抽象的类，体现在所有方法都为抽象方法。</p>
<p>定义类的关键字是class，而定义接口的关键字是interface。</p>
</li>
<li><p>接口和接口之间<strong>支持多继承</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BYD</span> <span class="keyword">extends</span> <span class="title class_">Car</span>,Owner&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>类支持单继承多实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BYDImpl</span> <span class="keyword">implements</span> <span class="title class_">Car</span>,Owner,BYD&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
<li><p><strong>抽象类和接口的主要区别</strong></p>
<p>定义抽象类的关键字是abstract class，而定义接口的关键字是interface。 </p>
<p>继承抽象类的关键字是extends，而实现接口的关键字是implements。 </p>
<p>继承抽象类支持单继承，而实现接口支持多实现。</p>
<p>抽象类中可以有构造方法，而接口中不可以有构造方法。</p>
<p><strong>抽象类中可以有成员变量，而接口中只可以有常量</strong></p>
<p><strong>抽象类中可以有成员方法，而接口中只可以有抽象方法。</strong></p>
<p>抽象类中增加方法时子类可以不用重写，而接口中增加方法时实现类需要重写（Java8以前的版本）。</p>
<p>从Java8开始增加新特性，接口中允许出现非抽象方法和静态方法，但非抽象方法需要使用default关键字修饰。 </p>
<p>从Java9开始增加新特性，接口中允许出现私有方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//必须初始化</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">    <span class="comment">// private int money;编译报错，private 不允许</span></span><br><span class="line">    <span class="comment">//没有default关键字编译报错</span></span><br><span class="line">    <span class="keyword">default</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;<span class="comment">// 子接口必须复写该方法，否则编译报错</span></span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210724171325385.png"></p>
</li>
</ol>
<h1 id="第十章-特殊类"><a href="#第十章-特殊类" class="headerlink" title="第十章 特殊类"></a><strong>第十章 特殊类</strong></h1><h2 id="一-、内部类"><a href="#一-、内部类" class="headerlink" title="一 、内部类"></a>一 、内部类</h2><h3 id="1-内部类的基本概念"><a href="#1-内部类的基本概念" class="headerlink" title="1. 内部类的基本概念"></a><strong>1. 内部类的基本概念</strong></h3><p>​        当一个类的定义出现在另外一个类的类体中时，那么这个类叫做内部类（Inner），而这个内部类所在的类叫做外部类（Outer）。</p>
<p>​        类中的内容：成员变量、成员方法、构造方法、静态成员、构造块和静态代码块、内部类</p>
<h3 id="2-实际作用"><a href="#2-实际作用" class="headerlink" title="2. 实际作用"></a><strong>2. 实际作用</strong></h3><p>​        当一个类存在的价值仅仅是为某一个类单独服务时，那么就可以将这个类定义为所服务类中的内部类，这样可以隐藏该类的实现细节        并且可以<strong>方便的访问外部类的私有成员而不再需要提供公有的get和set方法</strong></p>
<h3 id="3-内部类的分类"><a href="#3-内部类的分类" class="headerlink" title="3. 内部类的分类"></a>3. <strong>内部类的分类</strong></h3><p>​        普通内部类 ： 直接将一个类的定义放在另外一个类的类体中。</p>
<p>​        静态内部类 ： 使用static关键字修饰的内部类，隶属于类层级。</p>
<p>​        局部内部类 ： 直接将一个类的定义放在<strong>方法体的内部</strong>时。 </p>
<p>​        匿名内部类 ： 就是指没有名字的内部类。</p>
<h3 id="4-普通内部类的使用方式"><a href="#4-普通内部类的使用方式" class="headerlink" title="4. 普通内部类的使用方式"></a><strong>4. 普通内部类的使用方式</strong></h3><p>​        普通内部类和普通类一样可以定义成员变量、成员方法以及构造方法等。</p>
<p>​        普通内部类和普通类一样可以使用final或者abstract关键字修饰。</p>
<p>​        普通内部类还可以使用private或protected关键字进行修饰。</p>
<p>​        <strong>普通内部类需要使用外部类对象来创建对象。</strong></p>
<p>​        如果内部类访问外部类中与本类内部同名的成员变量或方法时，<strong>需要使用this关键字</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outer</span>().<span class="keyword">new</span> <span class="title class_">Inner</span>();<span class="comment">//使用内部类的方式</span></span><br></pre></td></tr></table></figure>

<h3 id="5-静态内部类的使用方式"><a href="#5-静态内部类的使用方式" class="headerlink" title="5. 静态内部类的使用方式"></a><strong>5. 静态内部类的使用方式</strong></h3><p>​        <strong>静态内部类不能直接访问外部类的非静态成员。</strong></p>
<p>​        静态内部类可以直接创建对象。</p>
<p>​        如果静态内部类访问外部类中与本类内同名的成员变量或方法时，需要使用类名.的方式访问。</p>
<h3 id="6-回调模式的概念"><a href="#6-回调模式的概念" class="headerlink" title="6. 回调模式的概念"></a><strong>6. 回调模式的概念</strong></h3><p>​        <strong>回调模式是指如果一个方法的参数是接口类型，则在调用该方法时，需要创建并传递一个实现此接口类型的对象；而该方法在运行时        会调用到参数对象中所实现的方法（接口中定义的）。</strong></p>
<h3 id="7-匿名内部类的语法格式"><a href="#7-匿名内部类的语法格式" class="headerlink" title="7. 匿名内部类的语法格式"></a><strong>7. 匿名内部类的语法格式</strong></h3><p>​        接口&#x2F;父类类型 引用变量名 &#x3D; new 接口&#x2F;父类类型() { 方法的重写 };</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">User user = new User() &#123;//没有类名，只有接口名和对象名</span><br><span class="line">    @Override</span><br><span class="line">    public void say() &#123;</span><br><span class="line">    System.out.println(&quot;这是匿名内部类&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> User user = new User() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void say() &#123;</span><br><span class="line">            System.out.println(&quot;这是匿名内部类&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void dance() &#123;</span><br><span class="line">            System.out.println(&quot;可以有多个实现方法&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>



<h3 id="二、枚举"><a href="#二、枚举" class="headerlink" title="二、枚举"></a><strong>二、枚举</strong></h3><h4 id="1-枚举的定义"><a href="#1-枚举的定义" class="headerlink" title="1. 枚举的定义"></a><strong>1. 枚举的定义</strong></h4><p>​    使用public static final表示的常量描述较为繁琐，使用enum关键字来定义枚举类型取代常量，枚举类型是从Java5开始增加的一种引用    数据类型。枚举值就是当前类的类型，也就是指向本类的对象，默认使用public static final关键字共同修饰，因此采用枚举类型.的方式    调用。枚举类可以自定义构造方法，但是构造方法的修饰符必须是private，默认也是私有的</p>
<h3 id="2-Enum类的概念和方法"><a href="#2-Enum类的概念和方法" class="headerlink" title="2. Enum类的概念和方法"></a>2. Enum类的概念和方法</h3><p>​    所有的<strong>枚举类都继承自java.lang.Enum类</strong>，常用方法如下：</p>
<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210724182437644.png" alt="image-20210724182437644"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Season</span> <span class="variable">season</span> <span class="operator">=</span> Season.spring;</span><br><span class="line">      <span class="comment">//Season season1 = new Season();// 编译报错</span></span><br><span class="line">      System.out.println(season.toString());</span><br><span class="line">      Season[] s = Season.values();</span><br><span class="line">      System.out.println(Arrays.toString(s));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">          System.out.println(s[i].ordinal());<span class="comment">//获取索引值</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="type">Season</span> <span class="variable">spring</span> <span class="operator">=</span> Season.valueOf(<span class="string">&quot;spring&quot;</span>);</span><br><span class="line">      System.out.println(spring.toString());</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>spring<br>[spring, summer, fail, winner]<br>0<br>1<br>2<br>3<br>spring</p>
<h3 id="3-枚举类实现接口的方式"><a href="#3-枚举类实现接口的方式" class="headerlink" title="3. 枚举类实现接口的方式"></a><strong>3. 枚举类实现接口的方式</strong></h3><pre><code> 枚举类实现接口后需要重写抽象方法，而重写方法的方式有两种：**重写一个，或者每个对象都重写。**
</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">color</span>&#123;</span><br><span class="line">    spring,</span><br><span class="line">    summer,</span><br><span class="line">    fail,</span><br><span class="line">    winner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">Season</span> <span class="keyword">implements</span> <span class="title class_">color</span>&#123;</span><br><span class="line">    spring &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    summer &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fail &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    winner &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">()</span> &#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="三、注解"><a href="#三、注解" class="headerlink" title="三、注解"></a>三、注解</h2><h4 id="1-注解的基本概念"><a href="#1-注解的基本概念" class="headerlink" title="1. 注解的基本概念"></a><strong>1. 注解的基本概念</strong></h4><p>​    注解（Annotation）又叫标注，是从Java5开始增加的一种引用数据类型。</p>
<p>​    注解本质上就是代码中的特殊标记，通过这些标记可以在编译、类加载、以及运行时执行指定的处理</p>
<h4 id="2-注解的语法格式"><a href="#2-注解的语法格式" class="headerlink" title="2. 注解的语法格式"></a><strong>2. 注解的语法格式</strong></h4><p>​    访问修饰符 @interface 注解名称 {</p>
<p>​    注解成员; </p>
<p>​    } </p>
<p>​    <strong>自定义注解自动继承java.lang.annotation.Annotation接口。</strong> </p>
<p>​    通过@注解名称的方式可以修饰包、类、 成员方法、成员变量、构造方法、参数、局部变量的声明等。</p>
<p>​    如果注解只有一个参数成员，建议使用参数名为value，而<strong>类型只能是八种基本数据类型、String类型、Class类型、enum类型及             Annotation类型。</strong></p>
<h4 id="3-元注解的概念"><a href="#3-元注解的概念" class="headerlink" title="3. 元注解的概念"></a><strong>3. 元注解的概念</strong></h4><p>​    元注解是可以注解到注解上的注解，或者说元注解是一种基本注解，但是它能够应用到其它的注解上面。 </p>
<p>​    元注解主要有 <strong>@Retention、@Documented、@Target、@Inherited、 @Repeatable</strong></p>
<p>  <strong>元注解@Retention</strong></p>
<p>​    @Retention 应用到一个注解用于说明该注解的的生命周期，取值如下：</p>
<p>​    RetentionPolicy.SOURCE 注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视。</p>
<p>​    RetentionPolicy.CLASS 注解只被保留到编译进行的时候，它并不会被加载到 JVM 中，默认方式。</p>
<p>​    RetentionPolicy.RUNTIME 注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时可以获取到它们。</p>
<p><strong>元注解@Documented</strong></p>
<p>​    用javadoc工具可以从程序源代码中抽取类、方法、成员等注释形成一个和源代码配套的API帮助文档，而该工具抽取时默认不包括注解    内容。</p>
<p>​    @Documented用于指定被该注解将被javadoc工具提取成文档。 </p>
<p>​    定义为@Documented的注解必须设置Retention值为RUNTIME。</p>
<p><strong>元注解@Target</strong></p>
<p>• @Target用于指定被修饰的注解能用于哪些元素的修饰，取值如下</p>
<p><img src="C:\Users\19591\AppData\Roaming\Typora\typora-user-images\image-20210724191930478.png" alt="image-20210724191930478"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Hello(&quot;ElementType.TYPE&quot;)</span></span><br><span class="line"><span class="comment">//@Hello(&quot;你好&quot;)</span></span><br><span class="line"><span class="comment">//@Hellos(&#123;@Hello(&quot;1&quot;),@Hello(&quot;2&quot;)&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="meta">@Hello(&quot;ElementType.FIELD&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">private</span>  String name;</span><br><span class="line">    <span class="meta">@Hello(&quot;ElementType.CONSTRUCTOR&quot;)</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="title function_">HelloWorld</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">say</span><span class="params">(<span class="meta">@Hello(&quot;ElementType.PARAMETER&quot;)</span> String username)</span> &#123;</span><br><span class="line">        <span class="meta">@Hello(&quot;ElementType.LOCAL_VARIABLE&quot;)</span></span><br><span class="line">        <span class="type">int</span> age;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> (<span class="meta">@Hello(&quot;ElementType.TYPE_USE:任何地方&quot;)</span> <span class="type">int</span>)<span class="number">3.14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>元注解@Inherited</strong></p>
<p>• @Inherited并不是说注解本身可以继承，而是说如果一个超类被该注解标记过的注解进行注解时，如果子类没有被任何注解应用时，则子类就继承超类的注解。</p>
<p><strong>元注解@Repeatable</strong></p>
<p>@Repeatable表示自然可重复的含义，从Java8开始增加的新特性。 </p>
<p>从Java8开始对元注解@Target的参数类型ElementType枚举值增加了两个： 其中ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语句中，如：泛型。</p>
<p>其中ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hellos &#123;</span><br><span class="line">    Hello[] value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repeatable(Hellos.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Hello &#123;</span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">Object</span>&gt;[] clazz() <span class="keyword">default</span> &#123;Object.class&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/25/JAVA%E5%9F%BA%E7%A1%80/" data-id="cl16iflor0001usvn85058sto" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2022/03/25/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/25/JAVA%E5%9F%BA%E7%A1%80/">(no title)</a>
          </li>
        
          <li>
            <a href="/2022/03/25/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>